<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>주제기반 실시간 크로스워드 15×15 (Canva 임베드용)</title>
<style>
  :root{ --size:40px; --gap:2px; --accent:#2563eb; --ink:#0f172a; --muted:#64748b; --bad:#ef4444; --ok:#10b981; }
  body{font-family:system-ui,Segoe UI,Roboto,"Noto Sans KR",sans-serif; margin:0; background:#f8fafc; color:var(--ink)}
  header{padding:14px 16px; display:flex; flex-wrap:wrap; gap:10px; align-items:center; border-bottom:1px solid #e5e7eb}
  h1{font-size:18px; margin:0}
  .row{display:flex; gap:8px; flex-wrap:wrap; align-items:center}
  input,button{font-size:14px}
  input[type=text]{padding:8px 10px; border:1px solid #cbd5e1; border-radius:10px; min-width:200px}
  button{padding:8px 12px; border:1px solid #cbd5e1; border-radius:10px; background:#fff; cursor:pointer}
  button.primary{border-color:var(--accent); background:var(--accent); color:#fff}
  .pill{border:1px solid #e2e8f0; border-radius:999px; padding:4px 8px; font-size:12px; color:#334155}
  .wrap{display:grid; grid-template-columns: 1fr 340px; gap:16px; padding:16px}
  @media(max-width:980px){ .wrap{grid-template-columns:1fr} }
  .board-wrap,.side{background:#fff; border:1px solid #e5e7eb; border-radius:12px; padding:12px}
  .board{display:grid; gap:var(--gap); justify-content:start}
  .cell{width:var(--size); height:var(--size); border:1px solid #e5e7eb; border-radius:6px; position:relative; display:flex; align-items:center; justify-content:center; background:#fff}
  .cell.block{background:#0f172a; border-color:#0f172a}
  .num{position:absolute; top:3px; left:5px; font-size:10px; color:#475569}
  .cell input{width:100%; height:100%; border:0; outline:0; background:transparent; text-align:center; font-size:20px; text-transform:uppercase; color:#0f172a}
  .cell.active{outline:2px solid var(--accent)}
  .cell.word{box-shadow: inset 0 0 0 2px rgba(37,99,235,.25)}
  small{color:var(--muted)}
  .hintlist{font-size:13px; line-height:1.45; max-height:260px; overflow:auto; border:1px dashed #e5e7eb; border-radius:10px; padding:8px}
  .hintlist li{margin:2px 0}
  .meters{display:flex; gap:8px; flex-wrap:wrap; margin:8px 0}
  progress{width:160px; height:14px}
  table{width:100%; border-collapse:collapse; font-size:13px}
  th,td{border-bottom:1px solid #e5e7eb; padding:6px 4px; text-align:left}
  .ok{color:var(--ok)}
  .bad{background:#fee2e2}
  .muted{color:#94a3b8}
</style>
</head>
<body>
<header>
  <h1>주제기반 실시간 크로스워드 15×15</h1>
  <div class="row">
    <input id="nick" type="text" placeholder="닉네임(멀티용)" style="min-width:120px"/>
    <input id="room" type="text" placeholder="방코드(예: 6-2-금요일)" />
    <button id="createRoom">방 생성</button>
    <button id="joinRoom" class="primary">방 접속</button>
    <span class="pill" id="roomInfo">방: 미연결(싱글모드)</span>
    <span class="pill" id="peers">참여자: 0</span>
  </div>
</header>

<div class="wrap">
  <section class="board-wrap">
    <div class="row" style="margin-bottom:8px">
      <input id="topic" type="text" placeholder="주제 입력 (예: 바다, 우주, 통영, 한국사)"/>
      <button id="fetchWords">단어 가져오기</button>
      <button id="build" class="primary">퍼즐 생성</button>
      <button id="check">오답 표시</button>
      <button id="reveal">현재 단어 공개</button>
      <span class="pill" id="dirPill">방향: 가로</span>
    </div>
    <div class="meters">
      <span class="pill" id="status">준비 완료</span>
      <span class="pill" id="timer">00:00</span>
      <progress id="prog" max="100" value="0"></progress>
      <span id="progTxt" class="pill">진행 0%</span>
    </div>
    <div id="board" class="board" role="grid" aria-label="crossword board"></div>
    <small>조작: 방향키 이동 / Space·Tab 가로↔세로 / Enter 다음 단어</small>
  </section>

  <aside class="side">
    <h3>힌트(자동 고도화)</h3>
    <ol id="hints" class="hintlist"></ol>
    <h3>랭킹(완료 시간)</h3>
    <table>
      <thead><tr><th>순위</th><th>닉네임</th><th>시간</th><th>진행</th></tr></thead>
      <tbody id="rank"><tr><td colspan="4" class="muted">싱글모드에서는 랭킹이 비활성화됩니다.</td></tr></tbody>
    </table>
  </aside>
</div>

<!-- Firebase (멀티플레이/랭킹용, 없으면 자동 싱글모드) -->
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>

<script>
/* =========== Firebase 설정 (선택) ===========
   ▶ 멀티/랭킹을 쓰려면 아래를 "네 프로젝트 값"으로 교체
   ▶ 교체 안 해도 싱글모드로 정상 작동
*/
const firebaseConfig = {
  apiKey: "YOUR_API_KEY",
  authDomain: "YOUR-PROJECT.firebaseapp.com",
  databaseURL: "https://YOUR-PROJECT-default-rtdb.firebaseio.com",
  projectId: "YOUR-PROJECT",
  storageBucket: "YOUR-PROJECT.appspot.com",
  messagingSenderId: "1234567890",
  appId: "YOUR_APP_ID"
};
/* =========================================== */

let MULTI_ENABLED = true;
for (const k of ["apiKey","authDomain","databaseURL","projectId","appId"]){
  if(!firebaseConfig[k] || String(firebaseConfig[k]).includes("YOUR_") || String(firebaseConfig[k]).includes("YOUR-")){
    MULTI_ENABLED = false; break;
  }
}

/* ===== 기본 상수/상태 ===== */
const SIZE = 15;
const MAX_WORDS = 20; // 가로+세로 합산 목표
const BADWORDS = ["시발","씨발","병신","병맛","개새","좆","sex","porn","fuck","shit","bitch","nazi","죽여","자살","폭탄","테러","마약","음란","혐오"];

let GRID = Array.from({length:SIZE},()=>Array(SIZE).fill('#'));
let numbers = Array.from({length:SIZE},()=>Array(SIZE).fill(null));
let direction = 'across';
let current = {r:0,c:0};
let WORDS = []; // {word, clue, _placed:{row,col,dir,clue,word}}
let ROOM = null, NICK = null;
let db=null, presenceRef=null;
let startAt=null, timerId=null;

/* ===== 유틸 ===== */
const setStatus = t => document.getElementById('status').textContent=t;
const inBounds = (r,c)=> r>=0 && c>=0 && r<SIZE && c<SIZE;
const id = (r,c)=> `r${r}c${c}`;
const now = ()=> Date.now();
const secToMMSS = s => { const m=Math.floor(s/60).toString().padStart(2,'0'); const ss=Math.floor(s%60).toString().padStart(2,'0'); return `${m}:${ss}`; };
function containsBadWord(s){ const lower = (s||"").toLowerCase(); return BADWORDS.some(b => lower.includes(b)); }
function normalizeWord(w){ const base=(w||"").replace(/\s|-/g,''); return /[가-힣]/.test(base) ? base : base.toUpperCase(); }
function escapeHtml(s){ return (s||'').replace(/[&<>"']/g,m=>({"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"}[m])); }

/* ===== 단어 수집(폴백 포함) + 힌트 고도화 ===== */
async function fetchRelatedWords(topic, max=60){
  const isKo = /[가-힣]/.test(topic);
  const enc = encodeURIComponent;
  const cleanup = (arr)=> {
    const uniq = []; const seen = new Set();
    for (let w of arr){
      if(!w) continue;
      if(containsBadWord(w)) continue;
      const nw = normalizeWord(w);
      if(nw.length < 2 || nw.length > 12) continue;
      if(/[^A-Za-z가-힣0-9]/.test(nw)) continue;
      if(seen.has(nw)) continue;
      seen.add(nw); uniq.push({word:nw, clue:`${nw.length}글자`});
    }
    return uniq.slice(0, max);
  };

  // 1) ConceptNet
  try{
    const lang = isKo ? 'ko' : 'en';
    const url = `https://api.conceptnet.io/related/c/${lang}/${enc(topic)}?filter=/c/${lang}&limit=${max}`;
    const r = await fetch(url, {mode:'cors'});
    if(r.ok){
      const data = await r.json();
      const list = (data.related||[]).map(x => (x['@id']||'').split('/').pop());
      let cand = cleanup(list);
      if(cand.length >= 10){ await enrichHints(cand.slice(0, 30), lang); return cand; }
    }
  }catch(e){}

  // 2) Wikipedia OpenSearch (CORS 허용)
  try{
    const lang = isKo ? 'ko' : 'en';
    const url = `https://${lang}.wikipedia.org/w/api.php?action=opensearch&search=${enc(topic)}&limit=${max}&namespace=0&format=json&origin=*`;
    const r = await fetch(url);
    if(r.ok){
      const j = await r.json();
      let cand = cleanup(j[1] || []);
      if(cand.length >= 10){ await enrichHints(cand.slice(0, 30), lang); return cand; }
    }
  }catch(e){}

  // 3) Datamuse (영문)
  try{
    const url = `https://api.datamuse.com/words?ml=${enc(topic)}&max=${max}`;
    const r = await fetch(url, {mode:'cors'});
    if(r.ok){
      const j = await r.json();
      let cand = cleanup(j.map(o=>o.word));
      await enrichHints(cand.slice(0, 30), 'en');
      return cand;
    }
  }catch(e){}

  // 4) 최후 폴백
  const seed = [topic, topic+'학', topic+'상식', topic+'기초', topic+'관련'];
  return cleanup(seed);
}

async function enrichHints(list, lang){
  for(const item of list){
    try{
      const q = encodeURIComponent(item.word);
      let url = `https://${lang}.wikipedia.org/api/rest_v1/page/summary/${q}`;
      let res = await fetch(url);
      if(!res.ok){
        const alt = lang === 'ko' ? 'en' : 'ko';
        url = `https://${alt}.wikipedia.org/api/rest_v1/page/summary/${q}`;
        res = await fetch(url);
      }
      if(res.ok){
        const j = await res.json();
        const txt = (j.extract||'').trim();
        if(txt){
          const sent = txt.split(/[.!?。]\s/).slice(0,2).join('. ');
          item.clue = sent.length>140 ? sent.slice(0,137)+'…' : sent;
        }
      }
    }catch(e){}
  }
}

/* ===== 퍼즐 배치(그리디) ===== */
function resetGrid(){ GRID = Array.from({length:SIZE},()=>Array(SIZE).fill('#')); numbers = Array.from({length:SIZE},()=>Array(SIZE).fill(null)); }
function numberGrid(){
  let n=1;
  for(let r=0;r<SIZE;r++){
    for(let c=0;c<SIZE;c++){
      if(GRID[r][c]==='#') continue;
      const startAcross = (c===0 || GRID[r][c-1]==='#') && (c+1<SIZE);
      const startDown   = (r===0 || GRID[r-1][c]==='#') && (r+1<SIZE);
      if(startAcross || startDown) numbers[r][c]=n++;
    }
  }
}
function writeWord(word,r,c,dir){ if(dir==='across'){ for(let i=0;i<word.length;i++) GRID[r][c+i]=word[i]; } else { for(let i=0;i<word.length;i++) GRID[r+i][c]=word[i]; } }
function placeFits(word, r, c, dir){
  if(dir==='across'){
    if(c<0 || c+word.length>SIZE || r<0 || r>=SIZE) return false;
    for(let i=0;i<word.length;i++){
      const ch = GRID[r][c+i];
      if(ch!=='#' && ch!==word[i]) return false;
      if(i===0 && c-1>=0 && GRID[r][c-1]!=='#') return false;
      if(i===word.length-1 && c+word.length<SIZE && GRID[r][c+word.length]!=='#') return false;
      if(r-1>=0 && GRID[r-1][c+i]!=='#' && GRID[r-1][c+i]!==word[i]) return false;
      if(r+1<SIZE && GRID[r+1][c+i]!=='#' && GRID[r+1][c+i]!==word[i]) return false;
    }
    return true;
  }else{
    if(r<0 || r+word.length>SIZE || c<0 || c>=SIZE) return false;
    for(let i=0;i<word.length;i++){
      const ch = GRID[r+i][c];
      if(ch!=='#' && ch!==word[i]) return false;
      if(i===0 && r-1>=0 && GRID[r-1][c]!=='#') return false;
      if(i===word.length-1 && r+word.length<SIZE && GRID[r+word.length][c]!=='#') return false;
      if(c-1>=0 && GRID[r+i][c-1]!=='#' && GRID[r+i][c-1]!==word[i]) return false;
      if(c+1<SIZE && GRID[r+i][c+1]!=='#' && GRID[r+i][c+1]!==word[i]) return false;
    }
    return true;
  }
}
function buildCrossword(words){
  resetGrid();
  words = [...words].sort((a,b)=> b.word.length - a.word.length);
  let placed = [];

  const first = words.shift();
  if(!first) return placed;
  const r0 = Math.floor(SIZE/2);
  const c0 = Math.max(0, Math.floor((SIZE - first.word.length)/2));
  writeWord(first.word, r0, c0, 'across');
  first._placed = {word:first.word,row:r0,col:c0,dir:'across',clue:first.clue};
  placed.push(first._placed);

  outer:
  for(const w of words){
    if(placed.length >= MAX_WORDS) break;
    for(const p of placed){
      for(let i=0;i<p.word.length;i++){
        const ch = p.word[i];
        for(let j=0;j<w.word.length;j++){
          if(w.word[j]!==ch) continue;
          if(p.dir==='across'){
            const r = p.row - j, c = p.col + i;
            if(placeFits(w.word,r,c,'down')){
              writeWord(w.word,r,c,'down');
              w._placed = {word:w.word,row:r,col:c,dir:'down',clue:w.clue};
              placed.push(w._placed);
              continue outer;
            }
          }else{
            const r = p.row + i, c = p.col - j;
            if(placeFits(w.word,r,c,'across')){
              writeWord(w.word,r,c,'across');
              w._placed = {word:w.word,row:r,col:c,dir:'across',clue:w.clue};
              placed.push(w._placed);
              continue outer;
            }
          }
        }
      }
    }
    for(let r=0;r<SIZE;r++){
      for(let c=0;c<SIZE;c++){
        if(placeFits(w.word,r,c,'across')){
          writeWord(w.word,r,c,'across');
          w._placed = {word:w.word,row:r,col:c,dir:'across',clue:w.clue};
          placed.push(w._placed);
          continue outer;
        }
        if(placeFits(w.word,r,c,'down')){
          writeWord(w.word,r,c,'down');
          w._placed = {word:w.word,row:r,col:c,dir:'down',clue:w.clue};
          placed.push(w._placed);
          continue outer;
        }
      }
    }
  }
  numberGrid();
  return placed;
}

/* ===== 렌더링/입력 ===== */
function render(){
  const board = document.getElementById('board');
  board.style.gridTemplateColumns = `repeat(${SIZE}, var(--size))`;
  board.innerHTML='';
  for(let r=0;r<SIZE;r++){
    for(let c=0;c<SIZE;c++){
      const cell = document.createElement('div');
      cell.id = id(r,c);
      const block = GRID[r][c]==='#';
      cell.className = 'cell' + (block?' block':'');
      if(!block){
        const num = numbers[r][c];
        if(num){ const t=document.createElement('div'); t.className='num'; t.textContent=num; cell.appendChild(t); }
        const inp=document.createElement('input');
        inp.maxLength=1; inp.dataset.r=r; inp.dataset.c=c;
        inp.value = getValue(r,c);
        inp.addEventListener('input', e=>{
          e.target.value = e.target.value.slice(0,1);
          pushValue(r,c,e.target.value);
          moveNext(r,c);
          updateProgress();
        });
        inp.addEventListener('keydown', e=>{
          if(e.key===' '||e.key==='Tab'){ e.preventDefault(); toggleDir(); }
          if(e.key==='Enter'){ e.preventDefault(); nextWord(); }
          if(/^Arrow/.test(e.key)){
            e.preventDefault();
            const map={ArrowLeft:[0,-1],ArrowRight:[0,1],ArrowUp:[-1,0],ArrowDown:[1,0]};
            const d=map[e.key], nr=r+d[0], nc=c+d[1];
            if(inBounds(nr,nc) && GRID[nr][nc]!=='#') focusCell(nr,nc,true);
          }
          if(e.key==='Backspace' && !e.target.value){
            const prev = prevCell(r,c);
            if(prev){ focusCell(prev.r,prev.c); pushValue(prev.r,prev.c,""); }
          }
        });
        cell.addEventListener('click', ()=> focusCell(r,c,true));
        cell.appendChild(inp);
      }
      board.appendChild(cell);
    }
  }
  focusFirst();
  renderHints();
}
function renderHints(){
  const list = document.getElementById('hints'); list.innerHTML='';
  const across = WORDS.filter(w=>w._placed && w._placed.dir==='across');
  const down   = WORDS.filter(w=>w._placed && w._placed.dir==='down');
  across.sort((a,b)=> numbers[a._placed.row][a._placed.col] - numbers[b._placed.row][b._placed.col]);
  down.sort((a,b)=> numbers[a._placed.row][a._placed.col] - numbers[b._placed.row][b._placed.col]);
  list.insertAdjacentHTML('beforeend','<strong>가로</strong>');
  for(const e of across){ const n = numbers[e.row][e.col]||'?'; list.insertAdjacentHTML('beforeend', `<li>${n}. ${escapeHtml(e.clue||'힌트 없음')}</li>`); }
  list.insertAdjacentHTML('beforeend','<strong>세로</strong>');
  for(const e of down){ const n = numbers[e.row][e.col]||'?'; list.insertAdjacentHTML('beforeend', `<li>${n}. ${escapeHtml(e.clue||'힌트 없음')}</li>`); }
}
function focusFirst(){ for(let r=0;r<SIZE;r++) for(let c=0;c<SIZE;c++){ if(GRID[r][c]!=='#'){ focusCell(r,c); return; } } }
function getEntryAt(r,c,dir){
  if(GRID[r][c]==='#') return null;
  let sr=r, sc=c, len=1;
  if(dir==='across'){
    while(sc-1>=0 && GRID[sr][sc-1]!=='#') sc--;
    let e=sc; while(e+1<SIZE && GRID[sr][e+1]!=='#') e++;
    len=e-sc+1;
  }else{
    while(sr-1>=0 && GRID[sr-1][sc]!=='#') sr--;
    let e=sr; while(e+1<SIZE && GRID[e+1][sc]!=='#') e++;
    len=e-sr+1;
  }
  return {row:sr,col:sc,len};
}
function highlightWord(){
  document.querySelectorAll('.cell').forEach(el=>el.classList.remove('word'));
  const ent = getEntryAt(current.r,current.c,direction);
  if(!ent) return;
  for(let i=0;i<ent.len;i++){
    const r = direction==='across'? ent.row : ent.row+i;
    const c = direction==='across'? ent.col+i : ent.col;
    const el = document.getElementById(id(r,c));
    el && el.classList.add('word');
  }
}
function focusCell(r,c,autoSwitch=false){
  current={r,c};
  document.querySelectorAll('.cell').forEach(el=>el.classList.remove('active','word','bad'));
  const el = document.getElementById(id(r,c));
  if(!el) return;
  el.classList.add('active');
  const entry = getEntryAt(r,c,direction);
  if(!entry && autoSwitch) direction = (direction==='across'?'down':'across');
  highlightWord();
  const inp = el.querySelector('input'); if(inp){ inp.focus(); inp.select(); }
  document.getElementById('dirPill').textContent = `방향: ${direction==='across'?'가로':'세로'}`;
}
function toggleDir(){ direction = direction==='across'?'down':'across'; document.getElementById('dirPill').textContent = `방향: ${direction==='across'?'가로':'세로'}`; highlightWord(); }
function moveNext(r,c){ const d = direction==='across'?[0,1]:[1,0]; const nr=r+d[0], nc=c+d[1]; if(inBounds(nr,nc) && GRID[nr][nc]!=='#') focusCell(nr,nc); }
function prevCell(r,c){ const d = direction==='across'?[0,-1]:[-1,0]; const nr=r+d[0], nc=c+d[1]; if(inBounds(nr,nc) && GRID[nr][nc]!=='#') return {r:nr,c:nc}; return null; }
function checkCurrent(){
  document.querySelectorAll('.cell').forEach(el=>el.classList.remove('bad'));
  const ent = getEntryAt(current.r,current.c,direction); if(!ent) return;
  for(let i=0;i<ent.len;i++){
    const r = direction==='across'? ent.row : ent.row+i;
    const c = direction==='across'? ent.col+i : ent.col;
    const val = (document.getElementById(id(r,c)).querySelector('input')?.value||'').toUpperCase();
    const ans = GRID[r][c].toUpperCase();
    if(val && val!==ans) document.getElementById(id(r,c)).classList.add('bad');
  }
}
function revealCurrent(){
  const ent = getEntryAt(current.r,current.c,direction); if(!ent) return;
  for(let i=0;i<ent.len;i++){
    const r = direction==='across'? ent.row : ent.row+i;
    const c = direction==='across'? ent.col+i : ent.col;
    pushValue(r,c, GRID[r][c]);
  }
}
function nextWord(){
  let starts=[];
  for(let r=0;r<SIZE;r++) for(let c=0;c<SIZE;c++){ if(numbers[r][c]) starts.push({r,c}); }
  starts.sort((a,b)=> numbers[a.r][a.c]-numbers[b.r][b.c]);
  let idx = starts.findIndex(s=> s.r===current.r && s.c===current.c);
  idx = (idx+1) % starts.length;
  focusCell(starts[idx].r, starts[idx].c);
}

/* ===== 진행도/타이머/랭킹 ===== */
function startTimer(){
  if(timerId) clearInterval(timerId);
  startAt = now();
  timerId = setInterval(()=>{ const secs=(now()-startAt)/1000; document.getElementById('timer').textContent = secToMMSS(secs); }, 300);
}
function updateProgress(){
  let total=0, correct=0;
  for(let r=0;r<SIZE;r++) for(let c=0;c<SIZE;c++){
    if(GRID[r][c]==='#') continue;
    total++;
    const val = (document.getElementById(id(r,c)).querySelector('input')?.value||'').toUpperCase();
    if(val===GRID[r][c].toUpperCase()) correct++;
  }
  const pct = Math.round(100*correct/total);
  document.getElementById('prog').value = pct;
  document.getElementById('progTxt').textContent = `진행 ${pct}%`;
  if(MULTI_ENABLED && ROOM && db && NICK){
    db.ref(`${roomPath()}/stats/${encode(NICK)}`).set({nick:NICK, progress:pct, updatedAt: now()});
    if(pct===100){
      db.ref(`${roomPath()}/finish/${encode(NICK)}`).get().then(s=>{
        if(!s.exists()){ db.ref(`${roomPath()}/finish/${encode(NICK)}`).set({ finishedAt: now(), nick:NICK }); }
      });
    }
  }
}
function bindRanking(){
  if(!MULTI_ENABLED || !ROOM||!db) return;
  db.ref(`${roomPath()}/finish`).on('value', snap=>{
    const tbody = document.getElementById('rank'); tbody.innerHTML='';
    const arr = []; const val = snap.val()||{};
    for(const k in val){ arr.push({nick:val[k].nick, finishedAt: val[k].finishedAt}); }
    arr.sort((a,b)=> a.finishedAt - b.finishedAt);
    if(arr.length===0){ tbody.innerHTML = `<tr><td colspan="4" class="muted">아직 기록이 없습니다.</td></tr>`; return; }
    arr.forEach((r,i)=>{
      db.ref(`${roomPath()}/stats/${encode(r.nick)}`).get().then(s=>{
        const prog = s.exists()? (s.val().progress||0) : 100;
        const tr = document.createElement('tr');
        const base = startAt ? secToMMSS((r.finishedAt-startAt)/1000) : '—';
        tr.innerHTML = `<td>${i+1}</td><td>${r.nick}</td><td>${base}</td><td>${prog}%</td>`;
        tbody.appendChild(tr);
      });
    });
  });
}

/* ===== 멀티플레이 동기화 ===== */
function initFirebase(){
  if(!MULTI_ENABLED){ setStatus('싱글모드: Firebase 미설정'); return; }
  try{
    const app=firebase.initializeApp(firebaseConfig);
    db=firebase.database();
  }catch(e){
    MULTI_ENABLED=false; setStatus('싱글모드: Firebase 초기화 실패'); 
    document.getElementById('roomInfo').textContent = `방: 미연결(싱글모드)`;
  }
}
function roomPath(){ return `rooms/${ROOM}`; }
function encode(s){ return encodeURIComponent(s).replace(/\./g, '%2E'); }

function pushValue(r,c,val){
  // 로컬 반영
  const el = document.getElementById(id(r,c))?.querySelector('input');
  if(el) el.value = (val||"").toUpperCase();
  // 멀티 반영
  if(MULTI_ENABLED && ROOM && db){ db.ref(`${roomPath()}/grid/${r}_${c}`).set((val||"").toUpperCase()); }
}
function getValue(r,c){ return ""; } // 초기 렌더는 공란

function bindRoom(){
  if(!MULTI_ENABLED){ return; }
  if(!ROOM || !db) return;
  db.ref(`${roomPath()}/grid`).on('value', snap=>{
    const obj = snap.val()||{};
    for(const k in obj){
      const [r,c] = k.split('_').map(Number);
      const el = document.getElementById(id(r,c))?.querySelector('input');
      if(el && el.value !== obj[k]) el.value = obj[k] || "";
    }
    updateProgress();
  });
  const conRef = db.ref('.info/connected');
  conRef.on('value', (snap) => {
    if (snap.val() === true) {
      const pRef = db.ref(`${roomPath()}/presence`).push(true);
      presenceRef = pRef; pRef.onDisconnect().remove();
    }
  });
  db.ref(`${roomPath()}/presence`).on('value', snap=>{
    const obj = snap.val()||{};
    document.getElementById('peers').textContent = `참여자: ${Object.keys(obj).length}`;
  });
  bindRanking();
}

/* ===== 이벤트 ===== */
document.getElementById('createRoom').addEventListener('click', ()=>{
  initFirebase();
  if(!MULTI_ENABLED){ alert('Firebase 미설정: 싱글모드로 실행됩니다.'); return; }
  NICK = document.getElementById('nick').value.trim() || `user-${Math.random().toString(36).slice(2,6)}`;
  ROOM = document.getElementById('room').value.trim();
  if(!ROOM){ alert('방코드를 입력하세요'); return; }
  db.ref(`${roomPath()}/meta`).set({ createdAt: now(), createdBy: NICK });
  document.getElementById('roomInfo').textContent = `방: ${ROOM}`;
  bindRoom();
});
document.getElementById('joinRoom').addEventListener('click', ()=>{
  initFirebase();
  if(!MULTI_ENABLED){ alert('Firebase 미설정: 싱글모드로 실행됩니다.'); return; }
  NICK = document.getElementById('nick').value.trim() || `user-${Math.random().toString(36).slice(2,6)}`;
  ROOM = document.getElementById('room').value.trim();
  if(!ROOM){ alert('방코드를 입력하세요'); return; }
  document.getElementById('roomInfo').textContent = `방: ${ROOM}`;
  bindRoom();
});

document.getElementById('fetchWords').addEventListener('click', async ()=>{
  const topic = document.getElementById('topic').value.trim();
  if(!topic){ alert('주제를 입력하세요'); return; }
  setStatus('연관 단어 수집 및 힌트 고도화 중…');
  try{
    let cand = await fetchRelatedWords(topic, 60);
    cand = cand.sort((a,b)=> b.word.length - a.word.length).slice(0,28);
    cand = cand.filter(x=>!containsBadWord(x.word));
    WORDS = cand;
    setStatus(`단어 ${WORDS.length}개 준비 완료. [퍼즐 생성]을 누르세요.`);
  }catch(e){
    console.error(e); setStatus('단어 수집 실패'); alert('네트워크/API 오류');
  }
});

document.getElementById('build').addEventListener('click', ()=>{
  if(!WORDS || WORDS.length===0){ alert('먼저 단어를 가져오세요.'); return; }
  const pool = [...WORDS].slice(0, 24);
  pool.forEach(w=> delete w._placed);
  const placed = buildCrossword(pool);
  WORDS = pool.filter(w=> w._placed).slice(0, MAX_WORDS);
  setStatus(`퍼즐 생성 완료: 실제 배치 ${WORDS.length}개`);
  render();
  startTimer();
  updateProgress();
  if(MULTI_ENABLED && ROOM && db && NICK){
    db.ref(`${roomPath()}/stats/${encode(NICK)}`).set({nick:NICK, progress:0, updatedAt: now()});
  }
});

document.getElementById('check').addEventListener('click', ()=> checkCurrent());
document.getElementById('reveal').addEventListener('click', ()=> revealCurrent());

document.getElementById('dirPill').textContent = `방향: ${direction==='across'?'가로':'세로'}`;
</script>
</body>
</html>
